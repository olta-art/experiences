<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Olta - Curated Experiences</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"
    integrity="sha512-CNgIRecGo7nphbeZ04Sc13ka07paqdeTu0WR1IM4kNcpmBAUSHSQX0FslNhTDadL4O5SAGapGt4FodqL8My0mA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="./main.js" type="module"></script>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7RGXWP7PJJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-7RGXWP7PJJ');
  </script>

  <!-- <a class="twitter-timeline" href="https://twitter.com/oltaArt?ref_src=twsrc%5Etfw">Tweets by you</a> -->
  <!-- <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> -->
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <!-- Mobile Detection and Playlist Default Script -->
  <script>
    // hi Vercel - heeeeellloo 
    // Immediate mobile detection and playlist default
    (function () {
      const isMobile = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      console.log('ðŸš€ IMMEDIATE MOBILE FIX - Is Mobile:', isMobile);

      if (isMobile) {
        // Set mobile flag for later use
        window.MOBILE_DEVICE_DETECTED = true;
        console.log('ðŸš€ Mobile device detected - will default to Desktop Experiences');

        // Try to update the dropdown immediately when DOM is ready
        document.addEventListener('DOMContentLoaded', function () {
          const dropdown = document.getElementById('playlist-dropdown');
          if (dropdown) {
            dropdown.value = 'mobile-optimized';
            console.log('ðŸš€ Updated dropdown to mobile-optimized for mobile');
          }

          // Update playlist header for mobile
          const header = document.getElementById('playlist-header');
          if (header) {
            const title = header.querySelector('.playlist-title');
            const desc = header.querySelector('.playlist-description');
            if (title) title.textContent = 'Mobile Optimized';
            if (desc) desc.textContent = 'Touch-friendly artworks optimized for mobile devices';
            console.log('ðŸš€ Updated header for mobile device');
          }

          // Check URL parameters - if they exist, let main.js handle routing
          const urlParams = new URLSearchParams(window.location.search);
          const artworkParam = urlParams.get('artwork');
          const playlistParam = urlParams.get('playlist');

          console.log('ðŸš€ Mobile detection - URL params:', { artworkParam, playlistParam });

          if (artworkParam || playlistParam) {
            console.log('ðŸš€ URL parameters detected - letting main.js handle routing:', { artworkParam, playlistParam });
            // Don't force any playlist change - let main.js handle it
            // But update the dropdown to show the correct playlist later
            setTimeout(() => {
              if (window.currentPlaylistId) {
                const dropdown = document.getElementById('playlist-dropdown');
                if (dropdown && dropdown.value !== window.currentPlaylistId) {
                  dropdown.value = window.currentPlaylistId;
                  console.log('ðŸš€ Updated dropdown to match main.js playlist:', window.currentPlaylistId);
                }
              }
            }, 2000); // Wait for main.js to finish routing
          } else {
            // Only force mobile-optimized if no URL parameters exist
            if (window.switchPlaylist && typeof window.switchPlaylist === 'function') {
              setTimeout(() => {
                window.switchPlaylist('mobile-optimized');
                console.log('ðŸš€ No URL params - switched to mobile-optimized playlist');
              }, 1000);
            }
          }
        });
      }
    })();
  </script>

  <meta property="og:title" content="Interactive Art Experiences | Olta">
  <meta property="og:description" content="Explore curated digital artworks and interactive experiences">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://experiences.olta.art">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Interactive Art Experiences | Olta">
  <meta name="twitter:description" content="Explore curated digital artworks and interactive experiences">
  <meta name="twitter:url" content="https://experiences.olta.art">
</head>

<body>
  <!-- Mobile Device Notice -->
  <div id="mobile-notice" class="mobile-notice">
    <div class="mobile-notice-content">
      <div class="mobile-notice-icon">ðŸ“±âœ¨</div>
      <div class="mobile-notice-text">
        <h3>Welcome Mobile Users! ðŸ“±</h3>
        <p>You're viewing our <strong>Mobile Optimized</strong> playlist with touch-friendly artworks! While some
          experiences work best on desktop, we've curated special mobile-friendly pieces just for you.</p>
        <div class="mobile-cta">
          <p><strong>ðŸ’¡ Pro tip:</strong> Visit on desktop for the full gesture-controlled experience!</p>
        </div>
        <button id="mobile-continue-btn" class="mobile-continue-btn">Start Exploring Mobile Artworks</button>
      </div>
    </div>
  </div>

  <!-- Top Left Status Bar for Playlist Selection -->
  <div id="top-left-status-bar">
    <span class="status-icon" aria-label="Playlist selector">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="3" y="4" width="18" height="2" rx="1" fill="#7be7b8" />
        <rect x="3" y="8" width="18" height="2" rx="1" fill="#7be7b8" />
        <rect x="3" y="12" width="18" height="2" rx="1" fill="#7be7b8" />
        <rect x="3" y="16" width="18" height="2" rx="1" fill="#7be7b8" />
      </svg>
    </span>
    <select id="playlist-dropdown">
      <option value="gesture-control">Gesture Control</option>
      <option value="desktop-experiences">Desktop Experiences</option>
      <option value="mobile-optimized">Mobile Optimized</option>
    </select>
  </div>

  <!-- Playlist Header - Repositioned and Styled -->
  <div id="playlist-header" class="playlist-header">
    <div class="playlist-title">Loading Experiences... [MOBILE OPTIMIZED]</div>
    <div class="playlist-description">Mobile devices now get a curated mobile-optimized playlist</div>
  </div>

  <!-- Top Right Status Bar (existing) -->
  <div id="top-status-bar">
    <span id="viewer-counter">
      <span class="status-icon" aria-label="Live viewers">
        <svg width="18" height="18" viewBox="0 0 20 20" fill="none">
          <circle cx="10" cy="7" r="4" stroke="#7be7b8" stroke-width="1.5" />
          <ellipse cx="10" cy="15" rx="7" ry="3" stroke="#7be7b8" stroke-width="1.5" />
        </svg>
      </span>
      Live viewers: <span id="viewer-count">0</span>
    </span>
    <span class="status-divider"></span>
    <button id="heart-btn" aria-label="Show appreciation">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"
          fill="currentColor" stroke="currentColor" stroke-width="0.5" />
      </svg>
    </button>
    <span id="heart-count">0</span>
    <span class="status-divider"></span>
    <button id="share-btn" aria-label="Share"
      style="background: none; border: none; cursor: pointer; padding: 0 0.1rem; margin-left: 0.3rem; display: flex; align-items: center; gap: 0.3rem;">
      <svg width="18" height="18" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M15 8V5a3 3 0 0 0-6 0v3" stroke="#7be7b8" stroke-width="1.5" stroke-linecap="round"
          stroke-linejoin="round" />
        <path d="M10 12v-1" stroke="#7be7b8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
        <path d="M5 8v7a3 3 0 0 0 3 3h4a3 3 0 0 0 3-3V8" stroke="#7be7b8" stroke-width="1.5" stroke-linecap="round"
          stroke-linejoin="round" />
        <path d="M10 12l-2-2m2 2l2-2" stroke="#7be7b8" stroke-width="1.5" stroke-linecap="round"
          stroke-linejoin="round" />
      </svg>
      <span style="color: #ffffff; font-size: 0.9rem; font-weight: 500;">Share</span>
    </button>
  </div>


  <!-- Rest of your existing HTML -->
  <div id="playlist-label" class="playlist-label"></div>
  <!-- Navigation feedback indicator -->
  <div id="nav-feedback" class="nav-feedback"></div>

  <!-- Carousel Navigation Buttons - Positioned directly in body like top status bar -->
  <button id="nav-prev-btn" class="carousel-nav-btn carousel-nav-left" aria-label="Previous project">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </svg>
  </button>
  <button id="nav-next-btn" class="carousel-nav-btn carousel-nav-right" aria-label="Next project">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M9 18l6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </svg>
  </button>

  <h1 id="loading">LOADING</h1>
  <button class="fullscreen">â›¶</button>

  <!-- Hidden navigation buttons for main.js functionality -->
  <button class="change" style="display: none;">Next Project</button>
  <button class="previous" style="display: none;">Previous Project</button>

  <template id="o-details">
    <div class="flex details-panel" part="flex" id="details-panel">
      <p part="qrcode" class="qrcodecanvas">
        <slot name="qrcode"></slot>
      </p>

      <h1 part="name">
        <slot name="name"></slot>
      </h1>
      <h2 part="creator">
        <slot name="creator"></slot>
      </h2>
      <!-- <p part="description">
        <slot name="description"></slot>
      </p> -->
    </div>
    </div>
  </template>
  <dialog class="options">
    <div class="button-container">
      <button class="close">close</button>
    </div>
    <form id="options-form"></form>
  </dialog>


  <script>
    // Your Firebase config here
    const firebaseConfig = {
      apiKey: "AIzaSyDDEb8UeIk6D0pxl_IWEMADqhLz4ZEsA2g",
      authDomain: "olta-70b79.firebaseapp.com",
      databaseURL: "https://olta-70b79-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "olta-70b79",
      storageBucket: "olta-70b79.appspot.com",
      messagingSenderId: "1009481982599",
      appId: "1:1009481982599:web:c625bd9f64d9625fae8e22"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // Generate unique viewer ID
    const viewerId = 'viewer_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    console.log('New viewer ID:', viewerId);

    // On page load - add this viewer
    const viewerRef = db.ref('viewers/' + viewerId);
    viewerRef.set({
      timestamp: Date.now(),
      userAgent: navigator.userAgent
    }).then(() => {
      console.log('âœ… Viewer added to database:', viewerId);
    }).catch((error) => {
      console.error('âŒ Error adding viewer:', error);
    });

    // Remove this viewer when they leave
    viewerRef.onDisconnect().remove().then(() => {
      console.log('âœ… Disconnect handler set for viewer:', viewerId);
    });

    // Display count
    db.ref('viewers').on('value', (snapshot) => {
      const count = snapshot.numChildren();
      const viewerCountElement = document.getElementById('viewer-count');
      if (viewerCountElement) {
        viewerCountElement.textContent = count;
        console.log('ðŸ“Š Live viewers updated:', count);

        // Show all current viewers for debugging
        const viewers = [];
        snapshot.forEach((childSnapshot) => {
          viewers.push(childSnapshot.key);
        });
        console.log('ðŸ‘¥ Current viewers:', viewers);
      } else {
        console.error('âŒ Viewer count element not found!');
      }
    }, (error) => {
      console.error('âŒ Error reading viewer count:', error);
    });

    // Clean up old viewers (older than 5 minutes)
    setInterval(() => {
      const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
      db.ref('viewers').once('value').then((snapshot) => {
        snapshot.forEach((childSnapshot) => {
          const viewer = childSnapshot.val();
          if (viewer && viewer.timestamp < fiveMinutesAgo) {
            childSnapshot.ref.remove();
            console.log('ðŸ§¹ Cleaned up old viewer:', childSnapshot.key);
          }
        });
      });
    }, 60000); // Check every minute

    // --- HEART REACTION LOGIC ---
    let currentHeartUnsubscribe = null;

    function getCurrentArtworkId() {
      if (window.currentProjectId) return window.currentProjectId;
      return 'static-4'; // fallback
    }

    function listenForHeartCount(artworkId) {
      // Remove previous listener if any
      if (currentHeartUnsubscribe) currentHeartUnsubscribe();
      const heartRef = db.ref('reactions/' + artworkId + '/heart');
      const handler = (snapshot) => {
        const count = snapshot.val() || 0;
        const heartCountElement = document.getElementById('heart-count');
        if (heartCountElement) heartCountElement.textContent = count;
      };
      heartRef.on('value', handler);
      // Provide a way to unsubscribe
      currentHeartUnsubscribe = () => heartRef.off('value', handler);
    }

    document.getElementById('heart-btn').addEventListener('click', () => {
      const artworkId = getCurrentArtworkId();
      const heartRef = db.ref('reactions/' + artworkId + '/heart');
      heartRef.transaction((current) => (current || 0) + 1);

      // Track heart reaction in Google Analytics
      if (window.gtag) {
        gtag('event', 'heart_reaction', {
          'artwork_id': artworkId,
          'playlist_id': window.currentPlaylistId || 'unknown'
        });
      }
    });

    // Initial listen for first artwork
    listenForHeartCount(getCurrentArtworkId());

    // Listen for artwork changes from main.js
    window.addEventListener('artworkChanged', (e) => {
      const newId = e.detail.id;
      listenForHeartCount(newId);

      // Track artwork view in Google Analytics
      if (window.gtag) {
        gtag('event', 'artwork_view', {
          'artwork_id': newId,
          'playlist_id': window.currentPlaylistId || 'unknown'
        });
      }
    });
    // --- END HEART REACTION LOGIC ---

    // Function to get current artwork info for sharing
    function getCurrentArtworkInfo() {
      console.log('=== SHARE DEBUG INFO ===');
      console.log('window.current:', window.current);
      console.log('window.projects:', window.projects);
      console.log('window.options.projects:', window.options?.projects);

      let projectName = '';
      let artistName = '';
      let artworkUrl = '';
      let twitterHandle = '';

      // Method 1: Use currentProject function
      if (window.currentProject && typeof window.currentProject === 'function') {
        const currentProj = window.currentProject();
        console.log('currentProject() result:', currentProj);
        if (currentProj) {
          projectName = currentProj.name || '';
          artistName = currentProj.creator?.profile?.name || '';
          artworkUrl = currentProj.lastAddedVersion?.animation?.url || '';

          // Get Twitter handle for this artwork
          twitterHandle = artworkTwitterHandles[projectName] || '';
        }
      }

      // Method 2: Direct array access
      if (!projectName && window.projects && window.current !== undefined) {
        const proj = window.projects[window.current];
        console.log('Direct array access result:', proj);
        if (proj) {
          projectName = proj.name || '';
          artistName = proj.creator?.profile?.name || '';
          artworkUrl = proj.lastAddedVersion?.animation?.url || '';
          twitterHandle = artworkTwitterHandles[projectName] || '';
        }
      }

      // Method 3: Get from DOM
      if (!projectName) {
        const detailsElement = document.querySelector('o-details');
        if (detailsElement && detailsElement.shadowRoot) {
          const nameSlot = detailsElement.shadowRoot.querySelector('slot[name="name"]');
          const creatorSlot = detailsElement.shadowRoot.querySelector('slot[name="creator"]');
          if (nameSlot) projectName = nameSlot.textContent || '';
          if (creatorSlot) artistName = creatorSlot.textContent || '';
          twitterHandle = artworkTwitterHandles[projectName] || '';
        }
      }

      console.log('Final share info:', { projectName, artistName, artworkUrl, twitterHandle });
      return { projectName, artistName, artworkUrl, twitterHandle };
    }

    // Expose the share function globally
    window.getCurrentArtworkInfo = getCurrentArtworkInfo;

    // Twitter handle mapping for all playlists
    const twitterHandles = {
      // Gesture Control Playlist
      "Shadows Touch Across Time": "@epok_tech",
      "Optical Verlet": "@xvijojo",
      "Dissolvi": "@seigneurrrr",
      "Peer into the Flow": "@peerintotheflow",

      // Desktop Experiences Playlist
      "FIELDS": "@fields_art",
      "Faded Memories": "@faded_memories_art", // Add actual handle
      "Morphed Radiance": "@morphed_radiance",
      "Meanwhile": "@meanwhile_art" // Add actual handle
    };

    // Get current playlist name for share text
    function getCurrentPlaylistName() {
      const playlistHeader = document.getElementById('playlist-header');
      if (playlistHeader) {
        const title = playlistHeader.querySelector('.playlist-title');
        return title ? title.textContent : 'Olta Playlist';
      }
      return 'Olta Playlist';
    }

    // Update the share button event listener
    document.getElementById('share-btn').addEventListener('click', async () => {
      console.log('[SHARE] Share button clicked');

      // Get current artwork ID with multiple fallbacks
      let artworkId = window.currentProjectId || '';

      // Try to get from options.projects and current index
      if (!artworkId && window.options && window.options.projects && typeof window.current !== 'undefined') {
        artworkId = window.options.projects[window.current] || '';
      }

      // Try to get from projects array
      if (!artworkId && window.projects && typeof window.current !== 'undefined') {
        const currentProject = window.projects[window.current];
        artworkId = currentProject ? currentProject.id : '';
      }

      console.log('[SHARE] Current artwork ID:', artworkId);

      // Get current artwork info with multiple fallbacks
      let projectName = '';
      let artistName = '';

      // Method 1: Use currentProject function
      if (window.currentProject && typeof window.currentProject === 'function') {
        const currentProj = window.currentProject();
        console.log('[SHARE] Current project:', currentProj);
        if (currentProj) {
          projectName = currentProj.name || '';
          artistName = currentProj.creator?.profile?.name || '';
        }
      }

      // Method 2: Try direct array access if function didn't work
      if (!projectName && window.projects && typeof window.current !== 'undefined') {
        const currentProject = window.projects[window.current];
        if (currentProject) {
          projectName = currentProject.name || '';
          artistName = currentProject.creator?.profile?.name || '';
        }
      }

      // Fallback: Get from DOM if project function doesn't work
      if (!projectName) {
        const detailsElement = document.querySelector('o-details');
        if (detailsElement && detailsElement.shadowRoot) {
          const nameSlot = detailsElement.shadowRoot.querySelector('slot[name="name"]');
          const creatorSlot = detailsElement.shadowRoot.querySelector('slot[name="creator"]');
          if (nameSlot) projectName = nameSlot.textContent || '';
          if (creatorSlot) artistName = creatorSlot.textContent || '';
        }
      }

      // Get Twitter handle for this artwork
      const twitterHandles = {
        "Shadows Touch Across Time": "@epok_tech",
        "Optical Verlet": "@xvijojo",
        "Dissolvi": "@seigneurrrr",
        "FIELDS": "@fields_art",
        "Faded Memories": "@faded_memories_art",
        "Morphed Radiance": "@morphed_radiance",
        "Meanwhile": "@meanwhile_art"
      };
      const twitterHandle = twitterHandles[projectName] || '';

      // Get current playlist info from main.js (more reliable than dropdown UI)
      let playlistId = window.currentPlaylistId || 'gesture-control';
      let playlistName = 'Gesture Control â€“ Interactive Experiences';

      // Map playlist IDs to names
      const playlistNames = {
        'gesture-control': 'Gesture Control â€“ Interactive Experiences',
        'desktop-experiences': 'Desktop Experiences'
      };

      if (playlistNames[playlistId]) {
        playlistName = playlistNames[playlistId];
      }

      // Build URLs - ALWAYS use the artwork ID, never the name
      // Use production domain instead of preview URL
      const baseUrl = 'https://experiences.olta.art';
      const artworkUrl = artworkId ? `${baseUrl}?artwork=${encodeURIComponent(artworkId)}` : baseUrl;
      const playlistUrl = `${baseUrl}?playlist=${encodeURIComponent(playlistId)}`;

      console.log('[SHARE] Built URLs:', { artworkUrl, playlistUrl });

      // Build share text with fallbacks
      let tweetText;
      if (projectName && artworkId) {
        tweetText = `Check out interactive artwork "${projectName}"`;
        if (twitterHandle) {
          tweetText += ` by ${twitterHandle}`;
        } else if (artistName) {
          tweetText += ` by ${artistName}`;
        }
        tweetText += ` from the curated playlist on Olta! ${artworkUrl}\n\nSee the full curated experience playlist here: ${playlistUrl}`;
      } else {
        // Fallback when no specific artwork is available
        tweetText = `Check out the curated interactive art experiences on Olta! ${baseUrl}\n\nExplore digital artworks that respond to your movements and interactions.`;
      }

      console.log('[SHARE] Final tweet text:', tweetText);

      // Show editable share dialog
      showShareDialog(tweetText, artworkUrl, playlistUrl);
    });

    // Function to show share dialog with editable text
    function showShareDialog(initialText, artworkUrl, playlistUrl) {
      // Create modal overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(8px);
      `;

      // Create dialog - styled to match top status bars
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: rgba(10, 10, 10, 0.85);
        border-radius: 1.1rem;
        padding: 1.5rem;
        max-width: 420px;
        width: 90%;
        color: white;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        border: none;
        backdrop-filter: blur(12px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      `;

      dialog.innerHTML = `
        <div style="display: flex; align-items: center; gap: 0.7rem; margin-bottom: 1rem;">
          <span style="color: #7be7b8;">
            <svg width="18" height="18" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M15 8V5a3 3 0 0 0-6 0v3" stroke="#7be7b8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
              <path d="M10 12v-1" stroke="#7be7b8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
              <path d="M5 8v7a3 3 0 0 0 3 3h4a3 3 0 0 0 3-3V8" stroke="#7be7b8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
              <path d="M10 12l-2-2m2 2l2-2" stroke="#7be7b8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
            </svg>
          </span>
          <h3 style="margin: 0; color: #fff; font-size: 1rem; font-weight: 500; letter-spacing: 0.01em;">Edit Share Text</h3>
        </div>
        <textarea id="share-text-editor" style="
          width: 100%;
          height: 120px;
          background: rgba(0, 0, 0, 0.3);
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 0.8rem;
          color: white;
          padding: 1rem;
          font-size: 0.9rem;
          line-height: 1.4;
          resize: vertical;
          font-family: inherit;
          box-sizing: border-box;
          backdrop-filter: blur(4px);
          outline: none;
          transition: border-color 0.2s ease;
        ">${initialText}</textarea>
        <div style="display: flex; gap: 0.7rem; margin-top: 1rem; justify-content: flex-end;">
          <button id="cancel-share" style="
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.8rem;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 400;
            font-family: inherit;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
          ">Cancel</button>
          <button id="copy-share" style="
            background: #7be7b8;
            border: none;
            color: #000;
            padding: 0.5rem 1rem;
            border-radius: 0.8rem;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.2s ease;
          ">Copy</button>
          <button id="tweet-share" style="
            background: #1da1f2;
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.8rem;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.2s ease;
          ">Share on Twitter</button>
        </div>
      `;

      overlay.appendChild(dialog);
      document.body.appendChild(overlay);

      // Focus on textarea and select all text
      const textarea = dialog.querySelector('#share-text-editor');
      setTimeout(() => {
        textarea.focus();
        textarea.select();
      }, 100);

      // Add hover effects and focus states
      const cancelBtn = dialog.querySelector('#cancel-share');
      const copyBtn = dialog.querySelector('#copy-share');
      const tweetBtn = dialog.querySelector('#tweet-share');

      // Textarea focus effect
      textarea.addEventListener('focus', () => {
        textarea.style.borderColor = 'rgba(123, 231, 184, 0.5)';
      });
      textarea.addEventListener('blur', () => {
        textarea.style.borderColor = 'rgba(255, 255, 255, 0.1)';
      });

      // Button hover effects
      cancelBtn.addEventListener('mouseenter', () => {
        cancelBtn.style.background = 'rgba(255, 255, 255, 0.2)';
        cancelBtn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      });
      cancelBtn.addEventListener('mouseleave', () => {
        cancelBtn.style.background = 'rgba(255, 255, 255, 0.1)';
        cancelBtn.style.borderColor = 'rgba(255, 255, 255, 0.2)';
      });

      copyBtn.addEventListener('mouseenter', () => {
        copyBtn.style.background = '#6bc49a';
        copyBtn.style.transform = 'translateY(-1px)';
      });
      copyBtn.addEventListener('mouseleave', () => {
        copyBtn.style.background = '#7be7b8';
        copyBtn.style.transform = 'translateY(0)';
      });

      tweetBtn.addEventListener('mouseenter', () => {
        tweetBtn.style.background = '#1991db';
        tweetBtn.style.transform = 'translateY(-1px)';
      });
      tweetBtn.addEventListener('mouseleave', () => {
        tweetBtn.style.background = '#1da1f2';
        tweetBtn.style.transform = 'translateY(0)';
      });

      // Event listeners
      dialog.querySelector('#cancel-share').addEventListener('click', () => {
        document.body.removeChild(overlay);
      });

      dialog.querySelector('#copy-share').addEventListener('click', async () => {
        const editedText = textarea.value;
        try {
          await navigator.clipboard.writeText(editedText);

          // Track share copy in Google Analytics
          if (window.gtag && window.currentProjectId) {
            gtag('event', 'share_copy', {
              'artwork_id': window.currentProjectId,
              'playlist_id': window.currentPlaylistId || 'unknown',
              'share_method': 'copy'
            });
          }

          // Show success feedback
          const button = dialog.querySelector('#copy-share');
          const originalText = button.textContent;
          button.textContent = 'Copied!';
          button.style.background = '#4ade80';
          setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#7be7b8';
          }, 2000);
        } catch (err) {
          console.warn('Could not copy to clipboard:', err);
          alert('Could not copy to clipboard');
        }
      });

      dialog.querySelector('#tweet-share').addEventListener('click', () => {
        const editedText = textarea.value;
        const encodedTweetText = encodeURIComponent(editedText);
        const twitterUrl = `https://twitter.com/intent/tweet?text=${encodedTweetText}`;

        // Track Twitter share in Google Analytics
        if (window.gtag && window.currentProjectId) {
          gtag('event', 'share_twitter', {
            'artwork_id': window.currentProjectId,
            'playlist_id': window.currentPlaylistId || 'unknown',
            'share_method': 'twitter'
          });
        }

        window.open(twitterUrl, '_blank');
        document.body.removeChild(overlay);
      });

      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          document.body.removeChild(overlay);
        }
      });

      // Close on Escape key
      document.addEventListener('keydown', function escapeHandler(e) {
        if (e.key === 'Escape') {
          document.body.removeChild(overlay);
          document.removeEventListener('keydown', escapeHandler);
        }
      });
    }

    const isMobile = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    async function requestCameraOnce() {
      if (!cameraStream && !isMobile) { // Only request on non-mobile
        try {
          cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
          // Use cameraStream for gesture artworks
        } catch (err) {
          console.error('Camera access error:', err);
        }
      }
    }

    if (isMobile) {
      // Show a message: "Gesture control is only available on desktop devices."
    }

    // Carousel navigation buttons - Robust implementation
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM Content Loaded - Looking for navigation elements...');

      let prevBtn = document.getElementById('nav-prev-btn');
      let nextBtn = document.getElementById('nav-next-btn');

      console.log('Navigation elements found:', {
        prevBtn,
        nextBtn
      });

      // Check if navigation functions are available
      console.log('Navigation functions available:', {
        navigatePrevious: typeof window.navigatePrevious,
        navigateNext: typeof window.navigateNext,
        current: window.current,
        options: window.options,
        projects: window.projects
      });

      // Debug: Check if elements are in DOM
      if (prevBtn) {
        console.log('Previous button styles:', window.getComputedStyle(prevBtn));
        console.log('Previous button position:', prevBtn.getBoundingClientRect());
        console.log('Previous button is visible:', prevBtn.offsetParent !== null);
        console.log('Previous button pointer-events:', window.getComputedStyle(prevBtn).pointerEvents);
      } else {
        console.error('Previous button not found in DOM!');
      }

      if (nextBtn) {
        console.log('Next button styles:', window.getComputedStyle(nextBtn));
        console.log('Next button position:', nextBtn.getBoundingClientRect());
        console.log('Next button is visible:', nextBtn.offsetParent !== null);
        console.log('Next button pointer-events:', window.getComputedStyle(nextBtn).pointerEvents);
      } else {
        console.error('Next button not found in DOM!');
      }

      // If buttons don't exist, create them dynamically
      if (!prevBtn || !nextBtn) {
        console.log('Creating navigation buttons dynamically...');

        if (!prevBtn) {
          const newPrevBtn = document.createElement('button');
          newPrevBtn.id = 'nav-prev-btn';
          newPrevBtn.className = 'carousel-nav-btn carousel-nav-left';
          newPrevBtn.setAttribute('aria-label', 'Previous project');
          newPrevBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>';
          document.body.appendChild(newPrevBtn);
          console.log('Created previous button dynamically');
        }

        if (!nextBtn) {
          const newNextBtn = document.createElement('button');
          newNextBtn.id = 'nav-next-btn';
          newNextBtn.className = 'carousel-nav-btn carousel-nav-right';
          newNextBtn.setAttribute('aria-label', 'Next project');
          newNextBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 18l6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>';
          document.body.appendChild(newNextBtn);
          console.log('Created next button dynamically');
        }

        // Re-get the buttons after creating them
        const newPrevBtn = document.getElementById('nav-prev-btn');
        const newNextBtn = document.getElementById('nav-next-btn');
        if (newPrevBtn) prevBtn = newPrevBtn;
        if (newNextBtn) nextBtn = newNextBtn;
      }

      // Function to handle previous navigation
      function handlePreviousNavigation(e) {
        console.log('Previous navigation triggered!');
        e.preventDefault();
        e.stopPropagation();

        // Visual feedback
        showNavigationFeedback('â† Previous Artwork', 'left');
        addButtonClickEffect(prevBtn);

        // Method 1: Try to dispatch custom event
        try {
          window.dispatchEvent(new CustomEvent('navigatePrevious'));
          console.log('Custom event dispatched');
        } catch (error) {
          console.error('Error dispatching custom event:', error);
        }

        // Method 2: Try to trigger hidden button
        try {
          const previousBtn = document.querySelector('.previous');
          if (previousBtn && !previousBtn.disabled) {
            console.log('Triggering hidden previous button click');
            previousBtn.click();
          } else {
            console.log('Hidden previous button not found or disabled');
          }
        } catch (error) {
          console.error('Error triggering hidden button:', error);
        }

        // Method 3: Try direct function call
        try {
          if (window.navigatePrevious && typeof window.navigatePrevious === 'function') {
            console.log('Calling navigatePrevious function directly');
            window.navigatePrevious();
          } else {
            console.log('navigatePrevious function not available');
          }
        } catch (error) {
          console.error('Error calling navigatePrevious function:', error);
        }

        // Method 4: Try to access main.js variables directly
        try {
          if (window.current !== undefined && window.options && window.options.projects) {
            console.log('Attempting direct navigation via main.js variables');
            window.current = window.decrementLoop ? window.decrementLoop(window.current, window.options.projects.length) : 0;
            if (window.viewer && window.getUrl) {
              window.viewer.setAttribute("url", window.getUrl());
            }
          }
        } catch (error) {
          console.error('Error with direct navigation:', error);
        }
      }

      // Function to handle next navigation
      function handleNextNavigation(e) {
        console.log('Next navigation triggered!');
        e.preventDefault();
        e.stopPropagation();

        // Visual feedback
        showNavigationFeedback('Next Artwork â†’', 'right');
        addButtonClickEffect(nextBtn);

        // Method 1: Try to dispatch custom event
        try {
          window.dispatchEvent(new CustomEvent('navigateNext'));
          console.log('Custom event dispatched');
        } catch (error) {
          console.error('Error dispatching custom event:', error);
        }

        // Method 2: Try to trigger hidden button
        try {
          const nextBtn = document.querySelector('.change');
          if (nextBtn && !nextBtn.disabled) {
            console.log('Triggering hidden next button click');
            nextBtn.click();
          } else {
            console.log('Hidden next button not found or disabled');
          }
        } catch (error) {
          console.error('Error triggering hidden button:', error);
        }

        // Method 3: Try direct function call
        try {
          if (window.navigateNext && typeof window.navigateNext === 'function') {
            console.log('Calling navigateNext function directly');
            window.navigateNext();
          } else {
            console.log('navigateNext function not available');
          }
        } catch (error) {
          console.error('Error calling navigateNext function:', error);
        }

        // Method 4: Try to access main.js variables directly
        try {
          if (window.current !== undefined && window.options && window.options.projects) {
            console.log('Attempting direct navigation via main.js variables');
            window.current = window.incrementLoop ? window.incrementLoop(window.current, window.options.projects.length) : 0;
            if (window.viewer && window.getUrl) {
              window.viewer.setAttribute("url", window.getUrl());
            }
          }
        } catch (error) {
          console.error('Error with direct navigation:', error);
        }
      }

      // Function to show navigation feedback
      function showNavigationFeedback(message, direction) {
        const feedback = document.getElementById('nav-feedback');
        if (feedback) {
          feedback.textContent = message;
          feedback.classList.add('show');

          // Remove the show class after animation completes
          setTimeout(() => {
            feedback.classList.remove('show');
          }, 1500);
        }

        // Console feedback
        console.log(`ðŸŽ¨ ${message} - Navigation triggered!`);
      }

      // Function to add button click effect
      function addButtonClickEffect(button) {
        if (button) {
          button.classList.add('clicked');
          setTimeout(() => {
            button.classList.remove('clicked');
          }, 600);
        }
      }

      if (prevBtn) {
        console.log('Adding click listener to previous button...');
        prevBtn.addEventListener('click', (e) => {
          console.log('Previous button clicked! Event:', e);
          handlePreviousNavigation(e);
        });
        // Add hover event listeners for debugging
        prevBtn.addEventListener('mouseenter', () => console.log('Previous button hover start'));
        prevBtn.addEventListener('mouseleave', () => console.log('Previous button hover end'));
        console.log('Previous button event listeners added successfully');
      } else {
        console.error('Previous carousel navigation button not found!');
      }

      if (nextBtn) {
        console.log('Adding click listener to next button...');
        nextBtn.addEventListener('click', (e) => {
          console.log('Next button clicked! Event:', e);
          handleNextNavigation(e);
        });
        // Add hover event listeners for debugging
        nextBtn.addEventListener('mouseenter', () => console.log('Next button hover start'));
        nextBtn.addEventListener('mouseleave', () => console.log('Next button hover end'));
        console.log('Next button event listeners added successfully');
      } else {
        console.error('Next carousel navigation button not found!');
      }

      // Add event listeners to overlays
      // The overlays are removed from the HTML, so this block is no longer needed.
      // if (leftOverlay) {
      //   leftOverlay.addEventListener('click', handlePreviousNavigation);
      //   console.log('Left overlay click listener added');
      // }

      // if (rightOverlay) {
      //   rightOverlay.addEventListener('click', handleNextNavigation);
      //   console.log('Right overlay click listener added');
      // }
    });

    // Playlist selector functionality
    document.addEventListener('DOMContentLoaded', () => {
      const playlistToggle = document.getElementById('playlist-toggle');
      const playlistDropdown = document.getElementById('playlist-dropdown');
      const currentPlaylistName = document.getElementById('current-playlist-name');

      if (playlistToggle && playlistDropdown) {
        // Toggle dropdown
        playlistToggle.addEventListener('click', () => {
          playlistDropdown.classList.toggle('show');
          playlistToggle.classList.toggle('active');
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!playlistToggle.contains(e.target) && !playlistDropdown.contains(e.target)) {
            playlistDropdown.classList.remove('show');
            playlistToggle.classList.remove('active');
          }
        });

        // Handle playlist selection
        const playlistOptions = document.querySelectorAll('.playlist-option');
        playlistOptions.forEach(option => {
          option.addEventListener('click', () => {
            const playlistId = option.dataset.playlist;
            const playlistTitle = option.querySelector('.playlist-option-title').textContent;

            // Update UI
            currentPlaylistName.textContent = playlistTitle;
            playlistOptions.forEach(opt => opt.classList.remove('active'));
            option.classList.add('active');

            // Close dropdown
            playlistDropdown.classList.remove('show');
            playlistToggle.classList.remove('active');

            // Switch playlists using the main.js function
            if (window.switchPlaylist && typeof window.switchPlaylist === 'function') {
              window.switchPlaylist(playlistId);
            } else {
              console.error('switchPlaylist function not available');
            }

            // Update playlist header
            const playlistHeader = document.getElementById('playlist-header');
            if (playlistHeader) {
              const title = playlistHeader.querySelector('.playlist-title');
              const desc = playlistHeader.querySelector('.playlist-description');

              if (playlistId === 'gesture-control') {
                title.textContent = 'Gesture Control - Interactive Experiences';
                desc.textContent = 'Motion-controlled digital artworks that respond to your movements';
              } else if (playlistId === 'desktop-experiences') {
                title.textContent = 'Desktop Experiences';
                desc.textContent = 'Interactive digital artworks for desktop viewing';
              } else if (playlistId === 'mobile-optimized') {
                title.textContent = 'Mobile Optimized';
                desc.textContent = 'Touch-friendly artworks optimized for mobile devices';
              }
            }
          });
        });
      }
    });

    // Playlist dropdown functionality
    document.addEventListener('DOMContentLoaded', () => {
      const playlistDropdown = document.getElementById('playlist-dropdown');

      if (playlistDropdown) {
        // Handle playlist selection
        playlistDropdown.addEventListener('change', (e) => {
          const playlistId = e.target.value;
          console.log('[PLAYLIST_UI] Switching to playlist:', playlistId);

          // Track playlist switch in Google Analytics
          if (window.gtag) {
            gtag('event', 'playlist_switch', {
              'playlist_id': playlistId,
              'previous_playlist': window.currentPlaylistId || 'unknown'
            });
          }

          // Switch playlists using the main.js function
          if (window.switchPlaylist && typeof window.switchPlaylist === 'function') {
            window.switchPlaylist(playlistId);
            // Show the playlist header again and start hide timer
            showPlaylistHeaderWithTimer();
          } else {
            console.error('switchPlaylist function not available');
          }

          // Update playlist header
          const playlistHeader = document.getElementById('playlist-header');
          if (playlistHeader) {
            const title = playlistHeader.querySelector('.playlist-title');
            const desc = playlistHeader.querySelector('.playlist-description');
            if (playlistId === 'gesture-control') {
              title.textContent = 'Gesture Control â€“ Interactive Experiences';
              desc.textContent = 'Motion-controlled digital artworks that respond to your movements';
            } else if (playlistId === 'desktop-experiences') {
              title.textContent = 'Desktop Experiences';
              desc.textContent = 'Interactive digital artworks for desktop viewing';
            } else if (playlistId === 'mobile-optimized') {
              title.textContent = 'Mobile Optimized';
              desc.textContent = 'Touch-friendly artworks optimized for mobile devices';
            }
          }
        });
      }
    });

    // Update top navigation button states when projects change
    function updateTopNavButtonStates() {
      const topPrevBtn = document.getElementById('nav-prev-btn');
      const topNextBtn = document.getElementById('nav-next-btn');
      const previousBtn = document.querySelector('.previous');
      const nextBtnMain = document.querySelector('.change');

      if (topPrevBtn && previousBtn) {
        topPrevBtn.disabled = previousBtn.disabled;
      }
      if (topNextBtn && nextBtnMain) {
        topNextBtn.disabled = nextBtnMain.disabled;
      }
    }

    // Listen for artwork changes to update button states
    window.addEventListener('artworkChanged', updateTopNavButtonStates);

    // Initial state update
    setTimeout(updateTopNavButtonStates, 2500);

    // Function to update the playlist header dynamically
    function updatePlaylistHeader(playlistId) {
      const playlistHeader = document.getElementById('playlist-header');
      if (!playlistHeader) return;
      const title = playlistHeader.querySelector('.playlist-title');
      const desc = playlistHeader.querySelector('.playlist-description');

      const playlists = {
        'gesture-control': {
          name: 'Gesture Control â€“ Interactive Experiences',
          description: 'Motion-controlled digital artworks that respond to your movements'
        },
        'desktop-experiences': {
          name: 'Desktop Experiences',
          description: 'Interactive digital artworks for desktop viewing'
        },
        'mobile-optimized': {
          name: 'Mobile Optimized',
          description: 'Touch-friendly artworks optimized for mobile devices'
        }
      };

      if (playlists[playlistId]) {
        title.textContent = playlists[playlistId].name;
        desc.textContent = playlists[playlistId].description;
      }
    }

    document.querySelectorAll('.playlist-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.playlist-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        window.switchPlaylist(btn.getAttribute('data-playlist'));
      });
    });

    // Set the first button (Gesture Control) as active by default
    const firstPlaylistBtn = document.querySelector('.playlist-btn');
    if (firstPlaylistBtn) {
      firstPlaylistBtn.classList.add('active');
    }

    // Navigation button event listeners - Simplified and more robust
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Setting up navigation buttons...');

      const prevBtn = document.getElementById('nav-prev-btn');
      const nextBtn = document.getElementById('nav-next-btn');

      console.log('Navigation buttons found:', { prevBtn, nextBtn });

      if (prevBtn) {
        prevBtn.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('Previous button clicked - calling navigatePrevious');
          console.log('window.navigatePrevious available:', typeof window.navigatePrevious);

          if (window.navigatePrevious && typeof window.navigatePrevious === 'function') {
            window.navigatePrevious();
          } else {
            console.error('navigatePrevious function not available!');
          }
        });
      }

      if (nextBtn) {
        nextBtn.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('Next button clicked - calling navigateNext');
          console.log('window.navigateNext available:', typeof window.navigateNext);

          if (window.navigateNext && typeof window.navigateNext === 'function') {
            window.navigateNext();
          } else {
            console.error('navigateNext function not available!');
          }
        });
      }

      // Keyboard navigation
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') {
          console.log('Left arrow key pressed');
          if (window.navigatePrevious && typeof window.navigatePrevious === 'function') {
            window.navigatePrevious();
          }
        } else if (e.key === 'ArrowRight') {
          console.log('Right arrow key pressed');
          if (window.navigateNext && typeof window.navigateNext === 'function') {
            window.navigateNext();
          }
        }
      });
    });

    // Auto-advance interval logic
    let projectInterval = null;

    // Update startProjectInterval to use setInterval only, and do NOT call navigateNext immediately
    function startProjectInterval() {
      clearInterval(projectInterval);
      projectInterval = setInterval(() => {
        if (window.navigateNext && window.isNavigationReady && window.isNavigationReady()) {
          window.navigateNext();
        }
      }, 10000); // 10 seconds for quick testing
    }

    // Variable to store the hide timer
    let playlistHideTimer = null;

    // Hide playlist description panel after 10 seconds
    function hidePlaylistDescriptionAfterDelay() {
      // Clear any existing timer
      if (playlistHideTimer) {
        clearTimeout(playlistHideTimer);
      }

      playlistHideTimer = setTimeout(() => {
        const playlistHeader = document.getElementById('playlist-header');
        if (playlistHeader) {
          playlistHeader.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
          playlistHeader.style.opacity = '0';
          playlistHeader.style.transform = 'translateY(-10px)';

          // Completely hide after fade animation
          setTimeout(() => {
            playlistHeader.style.display = 'none';
          }, 500);
        }
      }, 10000); // 10 seconds
    }

    // Function to show playlist header and start hide timer
    function showPlaylistHeaderWithTimer() {
      const playlistHeader = document.getElementById('playlist-header');
      if (playlistHeader) {
        // Show the header
        playlistHeader.style.display = 'block';
        playlistHeader.style.opacity = '1';
        playlistHeader.style.transform = 'translateY(0)';

        // Start the hide timer
        hidePlaylistDescriptionAfterDelay();
      }
    }

    // Start the hide timer when page loads
    document.addEventListener('DOMContentLoaded', () => {
      hidePlaylistDescriptionAfterDelay();
    });

    document.addEventListener('DOMContentLoaded', () => {
      const shareArtworkBtn = document.getElementById('share-artwork-btn');
      if (shareArtworkBtn) {
        shareArtworkBtn.addEventListener('click', async () => {
          const artworkId = window.currentProjectId || '';
          const url = `${window.location.origin}${window.location.pathname}?artwork=${encodeURIComponent(artworkId)}`;
          await navigator.clipboard.writeText(url);
          alert('Artwork link copied!');
          // Optionally open Twitter, etc.
        });
      }
    });

    document.getElementById('share-playlist-btn').addEventListener('click', async () => {
      const playlistDropdown = document.getElementById('playlist-dropdown');
      const playlistId = playlistDropdown ? playlistDropdown.value : 'gesture-control';
      const url = `${window.location.origin}${window.location.pathname}?playlist=${encodeURIComponent(playlistId)}`;
      await navigator.clipboard.writeText(url);
      alert('Playlist link copied!');
      // Optionally open Twitter, etc.
    });

    // Mobile Device Detection and Notice
    document.addEventListener('DOMContentLoaded', () => {
      const mobileNotice = document.getElementById('mobile-notice');
      const continueBtn = document.getElementById('mobile-continue-btn');

      // Check if device is mobile
      const isMobile = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isSmallScreen = window.innerWidth <= 768;

      if (isMobile || isSmallScreen) {
        // Show mobile notice
        mobileNotice.classList.add('show');

        // Handle continue button
        continueBtn.addEventListener('click', () => {
          mobileNotice.classList.remove('show');
          // Optionally track that user continued on mobile
          if (window.gtag) {
            gtag('event', 'mobile_continue', {
              'device_type': 'mobile',
              'screen_width': window.innerWidth
            });
          }
        });

        // Track mobile visit
        if (window.gtag) {
          gtag('event', 'mobile_visit', {
            'device_type': 'mobile',
            'screen_width': window.innerWidth
          });
        }
      }
    });


  </script>
</body>

</html>